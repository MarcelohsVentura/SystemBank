Usar os métodos de autenticação da classe Authentication

Na classe Authentication, ver se preciso usar o request no lugar da entity

Ver em quais pacotes terei classes da bankstatement (extrato) e como ela vai funcionar

A classe system (interativo) vai ter um switch para o usuário transitar entre as opções.

A classe system terá opção de login (método para autenticar o idnumber e password), após esta autenticação,
vai exibir a lista de contas do cliente, e ele escolherá qual quer acessar. Acessando, escolhe as operações.



















Classes transaction do service são design patterns strategy:
O padrão Strategy é indicado quando você precisa definir uma família de algoritmos, encapsulá-los individualmente e torná-los intercambiáveis sem alterar o código que os utiliza. Ele permite que o comportamento de uma classe seja selecionado em tempo de execução, promovendo a flexibilidade e a separação de responsabilidades.
Quando usar o padrão Strategy
Múltiplas variações de comportamento

Quando há várias implementações de um mesmo comportamento, e o código que utiliza esses comportamentos não deve depender de como eles são implementados.
Exemplo: Métodos de pagamento (cartão de crédito, boleto, Pix) em um sistema de e-commerce.
Evitar condicional excessivo (if/else ou switch)

Quando muitas condições são usadas para decidir qual comportamento executar, o Strategy organiza isso substituindo condicionais por diferentes classes.
Exemplo: Diferentes tipos de cálculo de desconto em um carrinho de compras.
Facilidade de extensão e manutenção

Quando você espera que novos comportamentos sejam adicionados com frequência, tornando mais fácil incluir novas estratégias sem modificar o código existente.
Exemplo: Tipos de validação para documentos em um sistema de autenticação.
Necessidade de alterar comportamentos dinamicamente

Quando o comportamento de uma classe precisa mudar em tempo de execução com base no contexto.
Exemplo: Modo de ataque de um personagem em um jogo que varia conforme a arma equipada.
Promover o Princípio Aberto-Fechado (OCP)

Permite adicionar novos comportamentos sem alterar o código que usa essas estratégias.
Exemplo: Algoritmos de ordenação diferentes para cenários específicos.
